# jvm数据区域


<!-- TOC -->

- [jvm数据区域](#jvm数据区域)
    - [1. 程序计数器](#1-程序计数器)
    - [2. Java虚拟机栈](#2-java虚拟机栈)
    - [3. 本地方法栈](#3-本地方法栈)
    - [4. Java堆](#4-java堆)
    - [5. 方法区](#5-方法区)
    - [6. 运行时常量池](#6-运行时常量池)
    - [内存溢出](#内存溢出)
    - [垃圾回收](#垃圾回收)

<!-- /TOC -->

![ae](../../img/java/jvm内存结构.jpg)

## 1. 程序计数器

**程序计数器（Program Counter Register）** ，也有称作为PC寄存器。在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址，当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。



虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示执行哪条指令的。



由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，**为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。** 因此，可以这么说，程序计数器是每个线程所私有的。



在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。



由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。



## 2. Java虚拟机栈

**Java虚拟机栈（Java Vitual Machine Stack）**，也就是我们常常所说的栈，跟C语言的数据段中的栈类似。事实上，Java栈是Java方法执行的内存模型。



Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(ReturnAddress)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。讲到这里，大家就应该会明白为什么 在 使用 递归方法的时候容易导致栈内存溢出的现象了，以及为什么栈区的空间不用程序员去管理了，这部分空间的分配和释放都是由系统自动实施的。

- 局部变量表，顾名思义，想必不用解释大家应该明白它的作用了吧。就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。
- 操作数栈，想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。
- 指向运行时常量池的引用，因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。
- 方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。

由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。



## 3. 本地方法栈

**本地方法栈（Native Method Stack）** 与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。在JVM规范中，并没有对本地方发栈的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。



## 4. Java堆

**Java堆(Java Heap)** 是Java虚拟机所管理的内存中最大的一块儿。Java
堆是被所有线程共享的一块儿内存区域,在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在java虚拟机规范中的描述是： 所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技能逐渐成熟,栈上分配、标量替换优化技术将会导致一些微妙的变化发生,所有的对象都分配在堆上也渐渐变得不那么“绝对”了。

Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”(Garbage Collected Heap)。从内存回收的角度来看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为： **新生代** 和 **老年代** ；再细致一点的有 **Eden空间**、**From Survivor空间**、**To Survivor空间** 等。


## 5. 方法区

**方法区（Method Area）** 与Java堆一样，是各个线程共享的内存区域。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与Java堆区分开来。在方法区中，存储的信息如下：

- 已被虚拟机加载的类信息（包括类的名称、方法信息、字段信息）
- 常量
- 静态变量
- 即时编译器编译后的代码等数据




## 6. 运行时常量池

**运行时常量池（Runtime Constant Pool）** 是方法区的一部分。Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是 **常量池（Constant Pool Table）**，用来存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译器才产生，也就是并非预置入Class文件中常量池的内容才能进入方法去运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用的比较多的便是`String`类的`intern()`方法。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出`OutOfMemoryErro`异常。



## 内存溢出

在JVM申请内存的过程中，会遇到无法申请到足够内存，从而导致内存溢出的情况。一般有以下几种情况：

虚拟机栈和本地方法栈溢出：

- `StackOverflowError`: 线程请求的栈深度大于虚拟机所允许的最大深度(循环递归)
- `OutOfMemoryError`: 虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存空间报此错误。（一般可以通过不停地创建线程引起此种情况）

Java堆溢出：

- 当创建大量对象并且对象生命周期都很长的情况下，会引发 `OutOfMemoryError`

运行时常量区溢出：

`OutOfMemoryError:PermGen space`，这里一个典型的例子就是String的intern方法，当大量字符串使用intern时，会触发此内存溢出

方法区溢出：

方法区存放Class等元数据信息，如果产生大量的类(使用cglib)，那么就会引发此内存溢出，`OutOfMemoryError:PermGen space`，在使用Hibernate等框架时会容易引起此种情况。

## 垃圾回收

**程序计数器**、**虚拟机栈**、**本地方法栈** 3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。
