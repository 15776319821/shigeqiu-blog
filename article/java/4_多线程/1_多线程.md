# 多线程

<!-- TOC -->

- [多线程](#多线程)
    - [实现方式](#实现方式)
    - [区别Thread的run与start](#区别thread的run与start)
    - [带返回值](#带返回值)
    - [同步工具类](#同步工具类)
    - [Synchronized和Static Synchronized区别](#synchronized和static-synchronized区别)
    - [关键方法](#关键方法)
        - [join()](#join)
        - [interrupt()](#interrupt)
        - [setDaemon()](#setdaemon)
        - [yield()](#yield)
        - [sleep()](#sleep)

<!-- /TOC -->

## 实现方式


- 一种是继承Thread类
- 另外一种是实现Runable接口。
- Thread类实际上也是实现了Runnable接口的类。

实现Runnable接口比继承Thread类所具有的优势：

- 1）：适合多个相同的程序代码的线程去处理同一个资源
- 2）：可以避免java中的单继承的限制
- 3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

## 区别Thread的run与start

- `start()` 方法来启动线程，真正实现了多线程运行，这时无需等待 `run()`方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的 `start()` 方法来启动一个线程，`start()` 方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），并没有运行，一旦得到cpu时间片，就开始执行 `run()` 方法， `run()` 方法称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。
- `run()` 方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待 `run()`方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。
    

## 带返回值

使用ExecutorService、Callable、Future实现有返回结果的多线程。ExecutorService、Callable、Future这个对象实际上都是属于Executor框架中的功能类。

##  同步工具类

- ReentrantLock（显示锁）
- ReentrantReadWriteLock（读写锁）
- Semaphore（信号量）
- CountDownLatch(闭锁)
- LimitLatch
- CyclicBarrier(栅栏)
- FutureTask

## Synchronized和Static Synchronized区别

synchronized是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有synchronized块，注意这里是“类的当前实例”， 类的两个不同实例就没有这种约束了。

那么static synchronized恰好就是要控制类的所有实例的访问了，static synchronized是限制线程同时访问jvm中该类的所有实例同时访问对应的代码块。


一个日本作者-结成浩的《java多线程设计模式》有这样的一个列子：

``` java
pulbic class Something(){
    public synchronized void isSyncA(){}
    public synchronized void isSyncB(){}
    public static synchronized void cSyncA(){}
    public static synchronized void cSyncB(){}
```

那么，加入有Something类的两个实例a与b，那么下列组方法何以被1个以上线程同时访问呢

``` java 

a. x.isSyncA()与x.isSyncB() 
b. x.isSyncA()与y.isSyncA()
c. x.cSyncA()与y.cSyncB()
d. x.isSyncA()与Something.cSyncA()
```

- a . 都是对同一个实例的synchronized域访问，因此不能被同时访问
- b . 是针对不同实例的，因此可以同时被访问
- c . 因为是`static synchronized`，所以不同实例之间仍然会被限制,相当于`Something.isSyncA()` 与 `Something.isSyncB()`了，因此不能被同时访问。
- d . 可以被同时访问的，理由是synchronzied的是实例方法与synchronzied的类方法由于锁定（lock）不同的原因。

结论：

A: synchronized static是某个类的范围，synchronized static cSync{}防止多个线程同时访问这个 类中的synchronized static 方法。它可以对类的所有对象实例起作用。

B: synchronized 是某实例的范围，synchronized isSync(){}防止多个线程同时访问这个实例中的synchronized 方法。


1. 对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性
2. 在静态方法上的锁，和 实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。
3. 关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。比如 `new A().x()` 和 `new A().x()`,对象不同，锁不同，如果A的单利的，就能互斥。
4. 静态方法加锁，能和所有其他静态方法加锁的 进行互斥。
5. **静态方法加锁，和xx.class 锁效果一样，直接属于类的。**

## 关键方法

Object 实例方法

- wait()
- wait()
- notify()
- notifyAll()

Thread实例方法

- start()
- join()
- interrupt()
- setDaemon()

Thread 静态方法

- yield()
- sleep()

### join()

``` java
public class JoinTest {
    public static void main(String [] args) throws InterruptedException {
        ThreadJoinTest t1 = new ThreadJoinTest("小明");
        ThreadJoinTest t2 = new ThreadJoinTest("小东");
        t1.start();
        /**join的意思是使得放弃当前线程的执行，并返回对应的线程，例如下面代码的意思就是：
         程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕
         所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会
         */
        t1.join();
        t2.start();
    }

}
class ThreadJoinTest extends Thread{
    public ThreadJoinTest(String name){
        super(name);
    }
    @Override
    public void run(){
        for(int i=0;i<10;i++){
            System.out.println(this.getName() + ":" + i);
        }
    }
}
```

上面程序结果是先打印完小明线程，在打印小东线程；　　

上面注释也大概说明了join方法的作用：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。注意，这里调用的join方法是没有传参的，join方法其实也可以传递一个参数给它的，具体看下面的简单例子：

``` java
public class JoinTest {
    public static void main(String [] args) throws InterruptedException {
        ThreadJoinTest t1 = new ThreadJoinTest("小明");
        ThreadJoinTest t2 = new ThreadJoinTest("小东");
        t1.start();
        /**join方法可以传递参数，join(10)表示main线程会等待t1线程10毫秒，10毫秒过去后，
         * main线程和t1线程之间执行顺序由串行执行变为普通的并行执行
         */
        t1.join(10);
        t2.start();
    }

}
```
上面代码结果是：程序执行前面10毫秒内打印的都是小明线程，10毫秒后，小明和小东程序交替打印。

所以，join方法中如果传入参数，则表示这样的意思：如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。需要注意的是，jdk规定，join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join()。

``` java
public class JoinTest {
    public static void main(String [] args) throws InterruptedException {
        ThreadJoinTest t1 = new ThreadJoinTest("小明");
        ThreadJoinTest t2 = new ThreadJoinTest("小东");
        /**join方法可以在start方法前调用时，并不能起到同步的作用
         */
        t1.join();
        t1.start();
        t2.start();
    }
}
```

上面代码执行结果是：小明和小东线程交替打印。


所以得到以下结论：join方法必须在线程start方法调用之后调用才有意义。这个也很容易理解：如果一个线程都没有start，那它也就无法同步了。

**join方法实现原理**

有了上面的例子，我们大概知道join方法的作用了，那么，join方法实现的原理是什么呢？

其实，join方法是通过调用线程的wait方法来达到同步的目的的。例如，A线程中调用了B线程的join方法，则相当于A线程调用了B线程的wait方法，在调用了B线程的wait方法后，A线程就会进入阻塞状态，具体看下面的源码：

从源码中可以看到：join方法的原理就是调用相应线程的wait方法进行等待操作的，例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。

### interrupt()

作用是中断本线程，本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。

如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。

如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。

如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。

中断一个“已终止的线程”不会产生任何操作。

### setDaemon()

要想设置一个线程为守护线程，setDaemon必须在start前调用。

当一个应用程序的所有非守护线程停止运行时，即使仍有守护线程还在运行，该应用程序也将终止，反过来，只要还有非守护线程在运行，应用程序就不会停止。我们可以通过setDaemon(booleanon)来设置某线程为精灵线程。

用户线程不完，jvm系统就不完，要是想只运行"守护Daemon线程",对不起jvm不给面子，不伺候，就关闭了，不给"守护Daemon线程"们单独运行的机会。


### yield()

Java线程中的Thread.yield( )方法，译为线程让步。顾名思义，就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行，注意是让自己或者其他线程运行，并不是单纯的让给其他线程。

yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！

举个例子：一帮朋友在排队上公交车，轮到Yield的时候，他突然说：我不想先上去了，咱们大家来竞赛上公交车。然后所有人就一块冲向公交车，

有可能是其他人先上车了，也有可能是Yield先上车了。

但是线程是有优先级的，优先级越高的人，就一定能第一个上车吗？这是不一定的，优先级高的人仅仅只是第一个上车的概率大了一点而已，

最终第一个上车的，也有可能是优先级最低的人。并且所谓的优先级执行，是在大量执行次数中才能体现出来的。

### sleep()

- 主要是为了暂停当前线程，把cpu片段让出给其他线程，减缓当前线程的执行。
- sleep是帮助其他线程获得运行机会的最好方法，但是如果当前线程获取到的有锁，sleep不会让出锁。
- 线程睡眠到期自动苏醒，并返回到可运行状态（就绪），不是运行状态。 
- sleep()是静态方法，只能控制当前正在运行的线程。
- 优先线程的调用，现在苏醒之后，并不会立马执行，所以sleep()中指定的时间是线程不会运行的最短时间，sleep方法不能作为精确的时间控制。 