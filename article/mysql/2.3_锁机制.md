# MySQL的锁机制
<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [MySQL的锁机制](#mysql的锁机制)
	- [概述](#概述)
	- [MyISAM表锁](#myisam表锁)
		- [显示的加锁](#显示的加锁)
		- [表级锁的争用情况](#表级锁的争用情况)
		- [并发锁](#并发锁)
		- [MyISAM的锁调度](#myisam的锁调度)
	- [InnoDB锁](#innodb锁)
		- [行锁的争用情况](#行锁的争用情况)
		- [行锁模式及加锁方法](#行锁模式及加锁方法)
		- [间隙锁（Next-Key锁）](#间隙锁next-key锁)
		- [关于死锁](#关于死锁)
	- [总结](#总结)

<!-- /TOC -->

## 概述


锁的类型：
- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

存储引擎用哪些锁：
- MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；
- BDB存储引擎采用的是页面锁（page-level
locking），但也支持表级锁；
- InnoDB存储引擎默认情况下是采用行级锁（row-level locking），也支持表级锁。


## MyISAM表锁
表级锁有两种模式：表共享读锁（Table Read Lock）、表独占写锁（Table Write Lock）
>  **MyISAM在执行查询语句（`SELECT`）前，会自动给涉及的所有表加读锁，在执行更新操作（`UPDATE、DELETE、INSERT`等）前，会自动给涉及的表加写锁。**

- 获取读锁后，多线程可以同时从数据表中读取数据,但会阻塞对同一表的写请求
- 获取写锁后，只有持有锁的线程可以对表进行更新操作，其他线程的读、写操作都会等待，直到锁被释放为止
- 读和写操作之间，以及写和写操作之间是串行的
- **这种机制造成了并发读写容易出现表锁争夺而导致阻塞访问**


### 显示的加锁

```sql
锁定表：LOCK TABLES tbl_name {READ | WRITE},[ tbl_name {READ | WRITE},…]

解锁表：UNLOCK TABLES
```
- 在用 `LOCK TABLES` 给表显式加表锁时,必须同时取得所有涉及到表的锁。
- 在执行 `LOCK TABLES` 后，只能访问显式加锁的这些表，不能访问未加锁的表;
- 如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。

**在自动加锁的情况下也基本如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁。这也正是 MyISAM 表不会出现死锁(Deadlock Free)的原因。**
例如：
```sql
LOCK TABLES test_table READ
UNLOCK test_table

LOCK TABLES test_table WRITE
UNLOCK test_table
```

当使用 LOCK TABLES 时,不仅需要一次锁定用到的所有表,而且,同一个表在 SQL 语句中出现多少次,就要通过与 SQL 语句中相同的别名锁定多少次,否则也会出错!
```sql
select
	a.first_name,
	b.first_name
from actor a,actor b
where a.first_name = b.first_name;
```
该Sql语句中，actor表以别名的方式出现了两次，分别是a,b，这时如果要在该Sql执行之前加锁就要使用以下Sql:
```sql
lock table actor as a read,actor as b read;
```
###  表级锁的争用情况

可以通过检查`table_locks_waited`和`table_locks_immediate`状态变量来分析系统上的表锁定争夺：

```sql
  mysql> show status like 'table%';
```
- `table_locks_immediate` 表示可以立即获取锁的次数
- `table_locks_waited` 表示不能立即获取锁，需要等待锁的次数

`table_locks_waited`/(`table_locks_immediate`+`table_locks_waited`) 这个比例值越大说明表级锁争用的情况越严重。  
 例：  比例值=0.01说明100次进程里就有一次是需要等待锁的进程；

### 并发锁
在一定条件下，MyISAM也支持查询和操作的并发进行。MyISAM存储引擎有一个系统变量`concurrent_insert`，专门用以控制其并发插入的行为，其值分别可以为0、1、2。
1. 当`concurrent_insert`设置为0时，不允许并发插入。
1. 当`concurrent_insert`设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。**这也是MySQL的默认设置。**
1. 当`concurrent_insert`设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。

可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入锁争用。例如，将`concurrent_insert`系统变量为2，总是允许并发插入；同时，通过定期在系统空闲时段执行`OPTIONMIZE TABLE`语句来整理空间碎片，收到因删除记录而产生的中间空洞。


### MyISAM的锁调度
即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！**这是因为MySQL认为写请求一般比读请求重要。** 这也正是MyISAM表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。这种情况有时可能会变得非常糟糕！幸好我们可以通过一些设置来调节MyISAM的调度行为。

- 通过指定启动参数`low-priority-updates`，使MyISAM引擎默认给予读请求以优先的权利。
- 通过执行命令`SET LOW_PRIORITY_UPDATES=1`，使该连接发出的更新请求优先级降低。
- 通过指定`INSERT、UPDATE、DELETE`语句的`LOW_PRIORITY`属性，降低该语句的优先级。

虽然上面3种方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。  

不要盲目的给mysql设置为读优先，因为一些需要长时间运行的查询操作，也会使写进程“饿死”。只有根据你的实际情况，来决定设置哪种操作优先。

另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数`max_write_lock_count`设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。

这里还要强调一点：一些需要长时间运行的查询操作，也会使写进程“饿死”！因此，应用中应尽量避免出现长时间运行的查询操作，不要总想用一条SELECT语句来解决问题。因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。

在一个有大数据量高并发表的mysql里，我们还可采用另一种策略来进行优化，那就是通过mysql主从（读写）分离来实现负载均衡，这样可避免优先哪一种操作从而可能导致另一种操作的堵塞。


## InnoDB锁
### 行锁的争用情况
```sql
mysql> show status like 'innodb_row_lock%';
+-------------------------------+-------+
| Variable_name | Value |
+-------------------------------+-------+
| Innodb_row_lock_current_waits | 0 |
| Innodb_row_lock_time | 0 |
| Innodb_row_lock_time_avg | 0 |
| Innodb_row_lock_time_max | 0 |
| Innodb_row_lock_waits | 0 |
+-------------------------------+-------+
5 rows in set (0.00 sec)
```
如果发现争用比较严重，如Innodb_row_lock_waits和Innodb_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。

### 行锁模式及加锁方法

InnoDB实现了以下两种类型的行锁。
- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
- 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。


另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

- 意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
- 意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。


如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。

- **意向锁** 是InnoDB自动加的，不需用户干预。
- 对于`UPDATE、DELETE、INSERT`语句，InnoDB会自动给涉及及数据集加**排他锁（X）**
- 对于普通SELECT语句，InnoDB不会任何锁；

事务可以通过以下语句显示给记录集加共享锁或排锁。

- 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`
- 排他锁（X）：`SELECT * FROM table_name WHERE ... FOR UPDATE`

用`SELECT .. IN SHARE MODE`获得共享锁，主要用在需要数据依存关系时确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用`SELECT ... FOR UPDATE`方式获取排他锁。

### 间隙锁（Next-Key锁）

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。  

举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的SQL：
```sql
SELECT * FROM emp WHERE empid > 100 FOR UPDATE
```
是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。   

InnoDB使用间隙锁的目的，一方面是为了 **防止幻读** ，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。  

很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。



### 关于死锁

MyISAM表锁是`deadlock free`的，这是因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但是在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了InnoDB发生死锁是可能的。


发生死锁后，InnoDB一般都能自动检测到，并使一个事务释放锁并退回，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数`innodb_lock_wait_timeout`来解决。需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获取所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖垮数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。

通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小、以及访问数据库的SQL语句，绝大部分都可以避免。下面就通过实例来介绍几种死锁的常用方法。

1. 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序为访问表，这样可以大大降低产生死锁的机会。如果两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可能避免。
1. 在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低死锁的可能。
1. 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁，甚至死锁。
1. 在REPEATEABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT...ROR UPDATE加排他锁，在没有符合该记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可以避免问题。
1. 当隔离级别为READ COMMITED时，如果两个线程都先执行SELECT...FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第１个线程提交后，第２个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第３个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。

尽管通过上面的设计和优化等措施，可以大减少死锁，但死锁很难完全避免。因此，在程序设计中总是捕获并处理死锁异常是一个很好的编程习惯。

如果出现死锁，可以用SHOW INNODB STATUS命令来确定最后一个死锁产生的原因和改进措施。

## 总结

**对于MyISAM的表锁，主要有以下几点:**

1. 共享读锁（S）之间是兼容的，但共享读锁（S）和排他写锁（X）之间，以及排他写锁之间（X）是互斥的，也就是说读和写是串行的。
2. 在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表和插入的锁争用问题。
3. MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置`LOW_PRIPORITY_UPDATES`参数，或在`INSERT、UPDATE、DELETE`语句中指定`LOW_PRIORITY`选项来调节读写锁的争用。
4. 由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。

**对于InnoDB表，主要有以下几点:**

1. InnoDB的行销是基于索引实现的，**如果不通过索引访问数据，InnoDB会使用表锁。**
1. InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。
1. 在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。
1. MyISAM的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。
1. 锁冲突甚至死锁很难完全避免。

**在了解InnoDB的锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：**

- 尽量使用较低的隔离级别
- 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会。
- 选择合理的事务大小，小事务发生锁冲突的几率也更小。
- 给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。
- 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大减少死锁的机会。
- 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。
- 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁。
- 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。
